{"version":3,"file":"static/js/725.c523d7a2.chunk.js","mappings":"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","sources":["../node_modules/react-swipeable/src/types.ts","../node_modules/react-swipeable/src/index.ts","welcome/pages/Welcome.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js"],"sourcesContent":["import * as React from \"react\";\n\nexport const LEFT = \"Left\";\nexport const RIGHT = \"Right\";\nexport const UP = \"Up\";\nexport const DOWN = \"Down\";\nexport type HandledEvents = React.MouseEvent | TouchEvent | MouseEvent;\nexport type Vector2 = [number, number];\nexport type SwipeDirections =\n  | typeof LEFT\n  | typeof RIGHT\n  | typeof UP\n  | typeof DOWN;\nexport interface SwipeEventData {\n  /**\n   * Absolute displacement of swipe in x. Math.abs(deltaX);\n   */\n  absX: number;\n  /**\n   * Absolute displacement of swipe in y. Math.abs(deltaY);\n   */\n  absY: number;\n  /**\n   * Displacement of swipe in x. (current.x - initial.x)\n   */\n  deltaX: number;\n  /**\n   * Displacement of swipe in y. (current.y - initial.y)\n   */\n  deltaY: number;\n  /**\n   * Direction of swipe - Left | Right | Up | Down\n   */\n  dir: SwipeDirections;\n  /**\n   * Source event.\n   */\n  event: HandledEvents;\n  /**\n   * True for the first event of a tracked swipe.\n   */\n  first: boolean;\n  /**\n   * Location where swipe started - [x, y].\n   */\n  initial: Vector2;\n  /**\n   * \"Absolute velocity\" (speed) - âˆš(absX^2 + absY^2) / time\n   */\n  velocity: number;\n  /**\n   * Velocity per axis - [ deltaX/time, deltaY/time ]\n   */\n  vxvy: Vector2;\n}\n\nexport type SwipeCallback = (eventData: SwipeEventData) => void;\nexport type TapCallback = ({ event }: { event: HandledEvents }) => void;\n\nexport type SwipeableDirectionCallbacks = {\n  /**\n   * Called after a DOWN swipe\n   */\n  onSwipedDown: SwipeCallback;\n  /**\n   * Called after a LEFT swipe\n   */\n  onSwipedLeft: SwipeCallback;\n  /**\n   * Called after a RIGHT swipe\n   */\n  onSwipedRight: SwipeCallback;\n  /**\n   * Called after a UP swipe\n   */\n  onSwipedUp: SwipeCallback;\n};\n\nexport type SwipeableCallbacks = SwipeableDirectionCallbacks & {\n  /**\n   * Called at start of a tracked swipe.\n   */\n  onSwipeStart: SwipeCallback;\n  /**\n   * Called after any swipe.\n   */\n  onSwiped: SwipeCallback;\n  /**\n   * Called for each move event during a tracked swipe.\n   */\n  onSwiping: SwipeCallback;\n  /**\n   * Called after a tap. A touch under the min distance, `delta`.\n   */\n  onTap: TapCallback;\n  /**\n   * Called for `touchstart` and `mousedown`.\n   */\n  onTouchStartOrOnMouseDown: TapCallback;\n  /**\n   * Called for `touchend` and `mouseup`.\n   */\n  onTouchEndOrOnMouseUp: TapCallback;\n};\n\n// Configuration Options\nexport type ConfigurationOptionDelta =\n  | number\n  | { [key in Lowercase<SwipeDirections>]?: number };\n\nexport interface ConfigurationOptions {\n  /**\n   * Min distance(px) before a swipe starts. **Default**: `10`\n   */\n  delta: ConfigurationOptionDelta;\n  /**\n   * Prevents scroll during swipe in most cases. **Default**: `false`\n   */\n  preventScrollOnSwipe: boolean;\n  /**\n   * Set a rotation angle. **Default**: `0`\n   */\n  rotationAngle: number;\n  /**\n   * Track mouse input. **Default**: `false`\n   */\n  trackMouse: boolean;\n  /**\n   * Track touch input. **Default**: `true`\n   */\n  trackTouch: boolean;\n  /**\n   * Allowable duration of a swipe (ms). **Default**: `Infinity`\n   */\n  swipeDuration: number;\n  /**\n   * Options for touch event listeners\n   */\n  touchEventOptions: { passive: boolean };\n}\n\nexport type SwipeableProps = Partial<SwipeableCallbacks & ConfigurationOptions>;\n\nexport type SwipeablePropsWithDefaultOptions = Partial<SwipeableCallbacks> &\n  ConfigurationOptions;\n\nexport interface SwipeableHandlers {\n  ref(element: HTMLElement | null): void;\n  onMouseDown?(event: React.MouseEvent): void;\n}\n\nexport type SwipeableState = {\n  cleanUpTouch?: () => void;\n  el?: HTMLElement;\n  eventData?: SwipeEventData;\n  first: boolean;\n  initial: Vector2;\n  start: number;\n  swiping: boolean;\n  xy: Vector2;\n};\n\nexport type StateSetter = (\n  state: SwipeableState,\n  props: SwipeablePropsWithDefaultOptions\n) => SwipeableState;\nexport type Setter = (stateSetter: StateSetter) => void;\nexport type AttachTouch = (\n  el: HTMLElement,\n  props: SwipeablePropsWithDefaultOptions\n) => () => void;\n","/* global document */\nimport * as React from \"react\";\nimport {\n  AttachTouch,\n  SwipeDirections,\n  DOWN,\n  SwipeEventData,\n  HandledEvents,\n  LEFT,\n  RIGHT,\n  Setter,\n  ConfigurationOptions,\n  SwipeableDirectionCallbacks,\n  SwipeableHandlers,\n  SwipeableProps,\n  SwipeablePropsWithDefaultOptions,\n  SwipeableState,\n  SwipeCallback,\n  TapCallback,\n  UP,\n  Vector2,\n} from \"./types\";\n\nexport {\n  LEFT,\n  RIGHT,\n  UP,\n  DOWN,\n  SwipeDirections,\n  SwipeEventData,\n  SwipeableDirectionCallbacks,\n  SwipeCallback,\n  TapCallback,\n  SwipeableHandlers,\n  SwipeableProps,\n  Vector2,\n};\n\nconst defaultProps: ConfigurationOptions = {\n  delta: 10,\n  preventScrollOnSwipe: false,\n  rotationAngle: 0,\n  trackMouse: false,\n  trackTouch: true,\n  swipeDuration: Infinity,\n  touchEventOptions: { passive: true },\n};\nconst initialState: SwipeableState = {\n  first: true,\n  initial: [0, 0],\n  start: 0,\n  swiping: false,\n  xy: [0, 0],\n};\nconst mouseMove = \"mousemove\";\nconst mouseUp = \"mouseup\";\nconst touchEnd = \"touchend\";\nconst touchMove = \"touchmove\";\nconst touchStart = \"touchstart\";\n\nfunction getDirection(\n  absX: number,\n  absY: number,\n  deltaX: number,\n  deltaY: number\n): SwipeDirections {\n  if (absX > absY) {\n    if (deltaX > 0) {\n      return RIGHT;\n    }\n    return LEFT;\n  } else if (deltaY > 0) {\n    return DOWN;\n  }\n  return UP;\n}\n\nfunction rotateXYByAngle(pos: Vector2, angle: number): Vector2 {\n  if (angle === 0) return pos;\n  const angleInRadians = (Math.PI / 180) * angle;\n  const x =\n    pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n  const y =\n    pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n  return [x, y];\n}\n\nfunction getHandlers(\n  set: Setter,\n  handlerProps: { trackMouse: boolean | undefined }\n): [\n  {\n    ref: (element: HTMLElement | null) => void;\n    onMouseDown?: (event: React.MouseEvent) => void;\n  },\n  AttachTouch\n] {\n  const onStart = (event: HandledEvents) => {\n    const isTouch = \"touches\" in event;\n    // if more than a single touch don't track, for now...\n    if (isTouch && event.touches.length > 1) return;\n\n    set((state, props) => {\n      // setup mouse listeners on document to track swipe since swipe can leave container\n      if (props.trackMouse && !isTouch) {\n        document.addEventListener(mouseMove, onMove);\n        document.addEventListener(mouseUp, onUp);\n      }\n      const { clientX, clientY } = isTouch ? event.touches[0] : event;\n      const xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n\n      props.onTouchStartOrOnMouseDown &&\n        props.onTouchStartOrOnMouseDown({ event });\n\n      return {\n        ...state,\n        ...initialState,\n        initial: xy.slice() as Vector2,\n        xy,\n        start: event.timeStamp || 0,\n      };\n    });\n  };\n\n  const onMove = (event: HandledEvents) => {\n    set((state, props) => {\n      const isTouch = \"touches\" in event;\n      // Discount a swipe if additional touches are present after\n      // a swipe has started.\n      if (isTouch && event.touches.length > 1) {\n        return state;\n      }\n\n      // if swipe has exceeded duration stop tracking\n      if (event.timeStamp - state.start > props.swipeDuration) {\n        return state.swiping ? { ...state, swiping: false } : state;\n      }\n\n      const { clientX, clientY } = isTouch ? event.touches[0] : event;\n      const [x, y] = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n      const deltaX = x - state.xy[0];\n      const deltaY = y - state.xy[1];\n      const absX = Math.abs(deltaX);\n      const absY = Math.abs(deltaY);\n      const time = (event.timeStamp || 0) - state.start;\n      const velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n      const vxvy: Vector2 = [deltaX / (time || 1), deltaY / (time || 1)];\n\n      const dir = getDirection(absX, absY, deltaX, deltaY);\n\n      // if swipe is under delta and we have not started to track a swipe: skip update\n      const delta =\n        typeof props.delta === \"number\"\n          ? props.delta\n          : props.delta[dir.toLowerCase() as Lowercase<SwipeDirections>] ||\n            defaultProps.delta;\n      if (absX < delta && absY < delta && !state.swiping) return state;\n\n      const eventData = {\n        absX,\n        absY,\n        deltaX,\n        deltaY,\n        dir,\n        event,\n        first: state.first,\n        initial: state.initial,\n        velocity,\n        vxvy,\n      };\n\n      // call onSwipeStart if present and is first swipe event\n      eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);\n\n      // call onSwiping if present\n      props.onSwiping && props.onSwiping(eventData);\n\n      // track if a swipe is cancelable (handler for swiping or swiped(dir) exists)\n      // so we can call preventDefault if needed\n      let cancelablePageSwipe = false;\n      if (\n        props.onSwiping ||\n        props.onSwiped ||\n        props[`onSwiped${dir}` as keyof SwipeableDirectionCallbacks]\n      ) {\n        cancelablePageSwipe = true;\n      }\n\n      if (\n        cancelablePageSwipe &&\n        props.preventScrollOnSwipe &&\n        props.trackTouch &&\n        event.cancelable\n      ) {\n        event.preventDefault();\n      }\n\n      return {\n        ...state,\n        // first is now always false\n        first: false,\n        eventData,\n        swiping: true,\n      };\n    });\n  };\n\n  const onEnd = (event: HandledEvents) => {\n    set((state, props) => {\n      let eventData: SwipeEventData | undefined;\n      if (state.swiping && state.eventData) {\n        // if swipe is less than duration fire swiped callbacks\n        if (event.timeStamp - state.start < props.swipeDuration) {\n          eventData = { ...state.eventData, event };\n          props.onSwiped && props.onSwiped(eventData);\n\n          const onSwipedDir =\n            props[\n              `onSwiped${eventData.dir}` as keyof SwipeableDirectionCallbacks\n            ];\n          onSwipedDir && onSwipedDir(eventData);\n        }\n      } else {\n        props.onTap && props.onTap({ event });\n      }\n\n      props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({ event });\n\n      return { ...state, ...initialState, eventData };\n    });\n  };\n\n  const cleanUpMouse = () => {\n    // safe to just call removeEventListener\n    document.removeEventListener(mouseMove, onMove);\n    document.removeEventListener(mouseUp, onUp);\n  };\n\n  const onUp = (e: HandledEvents) => {\n    cleanUpMouse();\n    onEnd(e);\n  };\n\n  /**\n   * The value of passive on touchMove depends on `preventScrollOnSwipe`:\n   * - true => { passive: false }\n   * - false => { passive: true } // Default\n   *\n   * NOTE: When preventScrollOnSwipe is true, we attempt to call preventDefault to prevent scroll.\n   *\n   * props.touchEventOptions can also be set for all touch event listeners,\n   * but for `touchmove` specifically when `preventScrollOnSwipe` it will\n   * supersede and force passive to false.\n   *\n   */\n  const attachTouch: AttachTouch = (el, props) => {\n    let cleanup = () => {};\n    if (el && el.addEventListener) {\n      const baseOptions = {\n        ...defaultProps.touchEventOptions,\n        ...props.touchEventOptions,\n      };\n      // attach touch event listeners and handlers\n      const tls: [\n        typeof touchStart | typeof touchMove | typeof touchEnd,\n        (e: HandledEvents) => void,\n        { passive: boolean }\n      ][] = [\n        [touchStart, onStart, baseOptions],\n        // preventScrollOnSwipe option supersedes touchEventOptions.passive\n        [\n          touchMove,\n          onMove,\n          {\n            ...baseOptions,\n            ...(props.preventScrollOnSwipe ? { passive: false } : {}),\n          },\n        ],\n        [touchEnd, onEnd, baseOptions],\n      ];\n      tls.forEach(([e, h, o]) => el.addEventListener(e, h, o));\n      // return properly scoped cleanup method for removing listeners, options not required\n      cleanup = () => tls.forEach(([e, h]) => el.removeEventListener(e, h));\n    }\n    return cleanup;\n  };\n\n  const onRef = (el: HTMLElement | null) => {\n    // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n    // ignore null here\n    if (el === null) return;\n    set((state, props) => {\n      // if the same DOM el as previous just return state\n      if (state.el === el) return state;\n\n      const addState: { cleanUpTouch?: () => void } = {};\n      // if new DOM el clean up old DOM and reset cleanUpTouch\n      if (state.el && state.el !== el && state.cleanUpTouch) {\n        state.cleanUpTouch();\n        addState.cleanUpTouch = void 0;\n      }\n      // only attach if we want to track touch\n      if (props.trackTouch && el) {\n        addState.cleanUpTouch = attachTouch(el, props);\n      }\n\n      // store event attached DOM el for comparison, clean up, and re-attachment\n      return { ...state, el, ...addState };\n    });\n  };\n\n  // set ref callback to attach touch event listeners\n  const output: { ref: typeof onRef; onMouseDown?: typeof onStart } = {\n    ref: onRef,\n  };\n\n  // if track mouse attach mouse down listener\n  if (handlerProps.trackMouse) {\n    output.onMouseDown = onStart;\n  }\n\n  return [output, attachTouch];\n}\n\nfunction updateTransientState(\n  state: SwipeableState,\n  props: SwipeablePropsWithDefaultOptions,\n  previousProps: SwipeablePropsWithDefaultOptions,\n  attachTouch: AttachTouch\n) {\n  // if trackTouch is off or there is no el, then remove handlers if necessary and exit\n  if (!props.trackTouch || !state.el) {\n    if (state.cleanUpTouch) {\n      state.cleanUpTouch();\n    }\n\n    return {\n      ...state,\n      cleanUpTouch: undefined,\n    };\n  }\n\n  // trackTouch is on, so if there are no handlers attached, attach them and exit\n  if (!state.cleanUpTouch) {\n    return {\n      ...state,\n      cleanUpTouch: attachTouch(state.el, props),\n    };\n  }\n\n  // trackTouch is on and handlers are already attached, so if preventScrollOnSwipe changes value,\n  // remove and reattach handlers (this is required to update the passive option when attaching\n  // the handlers)\n  if (\n    props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe ||\n    props.touchEventOptions.passive !== previousProps.touchEventOptions.passive\n  ) {\n    state.cleanUpTouch();\n\n    return {\n      ...state,\n      cleanUpTouch: attachTouch(state.el, props),\n    };\n  }\n\n  return state;\n}\n\nexport function useSwipeable(options: SwipeableProps): SwipeableHandlers {\n  const { trackMouse } = options;\n  const transientState = React.useRef({ ...initialState });\n  const transientProps = React.useRef<SwipeablePropsWithDefaultOptions>({\n    ...defaultProps,\n  });\n\n  // track previous rendered props\n  const previousProps = React.useRef<SwipeablePropsWithDefaultOptions>({\n    ...transientProps.current,\n  });\n  previousProps.current = { ...transientProps.current };\n\n  // update current render props & defaults\n  transientProps.current = {\n    ...defaultProps,\n    ...options,\n  };\n  // Force defaults for config properties\n  let defaultKey: keyof ConfigurationOptions;\n  for (defaultKey in defaultProps) {\n    if (transientProps.current[defaultKey] === void 0) {\n      (transientProps.current[defaultKey] as any) = defaultProps[defaultKey];\n    }\n  }\n\n  const [handlers, attachTouch] = React.useMemo(\n    () =>\n      getHandlers(\n        (stateSetter) =>\n          (transientState.current = stateSetter(\n            transientState.current,\n            transientProps.current\n          )),\n        { trackMouse }\n      ),\n    [trackMouse]\n  );\n\n  transientState.current = updateTransientState(\n    transientState.current,\n    transientProps.current,\n    previousProps.current,\n    attachTouch\n  );\n\n  return handlers;\n}\n","import React, { useState, useEffect, useContext } from 'react';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport Button from '../../shared/components/FormElements/Button';\r\nimport { AuthContext } from '../../shared/context/auth-context';\r\n\r\nimport { useSwipeable } from 'react-swipeable';\r\n\r\nimport movieNight from '../assets/img/movie-night.svg';\r\nimport watch from '../assets/img/watch.svg';\r\nimport './Welcome.css';\r\nconst Welcome = props => {\r\n    const auth = useContext(AuthContext);\r\n    const navigate = useNavigate();\r\n    const [isWelcome, setIsWelcome] = useState(true);\r\n\r\n    useEffect(() => {\r\n        auth.showFooterHandler(false);\r\n    }, []);\r\n\r\n    const continueOn = () => {\r\n        setIsWelcome(false);\r\n\r\n        // Change positions of the sliders. With our CSS it creates an animation\r\n        document.getElementById('slider-path').setAttribute('d', \"M16 4C16 1.79086 17.7909 0 20 0H36C38.2091 0 40 1.79086 40 4C40 6.20914 38.2091 8 36 8H20C17.7909 8 16 6.20914 16 4Z\");\r\n        document.getElementById('slider-rect').classList.add('rect-translate');\r\n    }\r\n\r\n    const getStarted = () => {\r\n        navigate('/collections');\r\n    }\r\n\r\n    const handlers = useSwipeable({\r\n        onSwipedLeft: () => {\r\n            if(isWelcome) {\r\n                setIsWelcome(false);\r\n\r\n                document.getElementById('slider-path').setAttribute('d', \"M16 4C16 1.79086 17.7909 0 20 0H36C38.2091 0 40 1.79086 40 4C40 6.20914 38.2091 8 36 8H20C17.7909 8 16 6.20914 16 4Z\");\r\n                document.getElementById('slider-rect').classList.add('rect-translate');\r\n            }\r\n        },\r\n        onSwipedRight: () => {\r\n            if(!isWelcome) {\r\n                setIsWelcome(true);\r\n                document.getElementById('slider-path').setAttribute('d', \"M0 4C0 1.79086 1.79086 0 4 0H20C22.2091 0 24 1.79086 24 4C24 6.20914 22.2091 8 20 8H4C1.79086 8 0 6.20914 0 4Z\");\r\n                document.getElementById('slider-rect').classList.remove('rect-translate');\r\n            }\r\n        },\r\n        preventDefaultTouchmoveEvent: true,\r\n        trackMouse: true\r\n    });\r\n\r\n    let welcome = (\r\n        <React.Fragment>\r\n            <h2 className='welcome-header'>Welcome to Choice Champ!</h2>\r\n            <p className='welcome-text'>\r\n                Having a hard time choosing what to watch or play together?\r\n                <br />\r\n                <br />\r\n                Choice Champ is here to make that choice a little easier.\r\n            </p>\r\n            <Button className=\"welcome-btn\" onClick={continueOn}>\r\n                Continue \r\n            </Button>\r\n        </React.Fragment>\r\n    );\r\n\r\n    let info = (\r\n        <React.Fragment>\r\n            <h2 className='welcome-header'>Here's how we do things!</h2>\r\n            <ol className='welcome-list'>\r\n                <li>Create Collections</li>\r\n                <li>Start a Choice Party</li>\r\n                <li>Share Party Code to group</li>\r\n                <li>Choose Together!</li>\r\n            </ol>\r\n            <Button className=\"welcome-btn\" onClick={getStarted}>\r\n                Get Started \r\n            </Button>\r\n        </React.Fragment>\r\n    );\r\n\r\n    return (\r\n        <div className='welcome' {...handlers}>\r\n            <img src={isWelcome ? movieNight : watch} className=\"welcome-img\" alt='Movie night'/>\r\n                <svg id='slider' width=\"40\" height=\"8\" viewBox=\"0 0 40 8\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\r\n                    <path id='slider-path' d=\"M0 4C0 1.79086 1.79086 0 4 0H20C22.2091 0 24 1.79086 24 4C24 6.20914 22.2091 8 20 8H4C1.79086 8 0 6.20914 0 4Z\" fill=\"#FCB016\"/>\r\n                    <rect id='slider-rect' opacity=\"0.52\" x=\"32\" width=\"8\" height=\"8\" rx=\"4\" fill=\"white\"/>\r\n                </svg>\r\n            {isWelcome ? welcome : info}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Welcome;","import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nexport default function _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}"],"names":["LEFT","RIGHT","UP","DOWN","defaultProps","delta","preventScrollOnSwipe","rotationAngle","trackMouse","trackTouch","swipeDuration","Infinity","touchEventOptions","passive","initialState","first","initial","start","swiping","xy","mouseMove","mouseUp","touchEnd","touchMove","touchStart","rotateXYByAngle","pos","angle","angleInRadians","Math","PI","cos","sin","getHandlers","set","handlerProps","onStart","event","isTouch","touches","length","state","props","document","addEventListener","onMove","onUp","_ref","clientX","clientY","onTouchStartOrOnMouseDown","Object","assign","slice","timeStamp","_ref2","_rotateXYByAngle","_rotateXYByAngle2","_slicedToArray","x","y","deltaX","deltaY","absX","abs","absY","time","velocity","sqrt","vxvy","dir","getDirection","toLowerCase","eventData","onSwipeStart","onSwiping","cancelablePageSwipe","onSwiped","concat","cancelable","preventDefault","onEnd","onSwipedDir","onTap","onTouchEndOrOnMouseUp","cleanUpMouse","removeEventListener","e","attachTouch","el","cleanup","baseOptions","tls","forEach","_ref3","_ref4","h","o","_ref5","_ref6","output","ref","addState","cleanUpTouch","onMouseDown","useSwipeable","options","defaultKey","transientState","React","transientProps","previousProps","current","_React$useMemo","stateSetter","_React$useMemo2","handlers","undefined","updateTransientState","auth","useContext","AuthContext","navigate","useNavigate","_useState","useState","_useState2","isWelcome","setIsWelcome","useEffect","showFooterHandler","onSwipedLeft","getElementById","setAttribute","classList","add","onSwipedRight","remove","preventDefaultTouchmoveEvent","welcome","_jsxs","children","_jsx","className","Button","onClick","info","_objectSpread","src","movieNight","watch","alt","id","width","height","viewBox","fill","xmlns","d","opacity","rx","_defineProperty","obj","key","value","defineProperty","enumerable","configurable","writable","ownKeys","r","t","keys","getOwnPropertySymbols","filter","getOwnPropertyDescriptor","push","apply","_objectSpread2","arguments","getOwnPropertyDescriptors","defineProperties"],"sourceRoot":""}